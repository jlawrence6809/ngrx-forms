{"version":3,"file":"ngrx-forms-validation.umd.js","sources":["ng://ngrx-forms/validation/src/email.ts","ng://ngrx-forms/validation/src/equal-to.ts","ng://ngrx-forms/validation/src/greater-than.ts","ng://ngrx-forms/validation/src/greater-than-or-equal-to.ts","ng://ngrx-forms/validation/src/less-than.ts","ng://ngrx-forms/validation/src/less-than-or-equal-to.ts","ng://ngrx-forms/validation/src/max-length.ts","ng://ngrx-forms/validation/src/min-length.ts","ng://ngrx-forms/validation/src/not-equal-to.ts","ng://ngrx-forms/validation/src/pattern.ts","ng://ngrx-forms/validation/src/required.ts","ng://ngrx-forms/validation/src/required-false.ts","ng://ngrx-forms/validation/src/required-true.ts"],"sourcesContent":["import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\n// this regex is taken from the @angular/forms source code\n// tslint:disable-next-line:max-line-length\nexport const NGRX_FORMS_EMAIL_VALIDATION_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n\nexport interface EmailValidationError {\n  pattern: string;\n  actual: string;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    email?: EmailValidationError;\n  }\n}\n\n/**\n * A validation function that requires a value to be a valid e-mail address.\n * Considers `null`, `undefined`, and `''` as valid. Combine this function with the\n * `required` validation function if these values should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  email: {\n    pattern: string;\n    actual: string;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  userMailAddress: validate(email),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function email<T extends string | Boxed<string> | null | undefined>(value: T): ValidationErrors {\n  value = unbox(value) as string | null | undefined as T;\n\n  if (value === null || value === undefined || (value as string).length === 0) {\n    return {};\n  }\n\n  if (NGRX_FORMS_EMAIL_VALIDATION_REGEXP.test(value as string)) {\n    return {};\n  }\n\n  return {\n    email: {\n      pattern: NGRX_FORMS_EMAIL_VALIDATION_REGEXP.toString(),\n      actual: value as string,\n    },\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface EqualToValidationError<T> {\n  comparand: T;\n  actual: T;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    equalTo?: EqualToValidationError<any>;\n  }\n}\n\n/**\n * A validation function that requires the value to be strictly equal (i.e. `===`)\n * to another value.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  equalTo: {\n    comparand: T;\n    actual: T;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  name: validate(equalTo('John Doe')),\n})\n```\n */\nexport function equalTo<T>(comparand: T) {\n  return <TV extends T | Boxed<T> = T>(value: TV): ValidationErrors => {\n    value = unbox(value) as T as TV;\n\n    if (value === comparand) {\n      return {};\n    }\n\n    return {\n      equalTo: {\n        comparand,\n        actual: value,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface GreaterThanValidationError {\n  comparand: number;\n  actual: number;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    greaterThan?: GreaterThanValidationError;\n  }\n}\n\n/**\n * A validation function that requires the value to be greater than a number.\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\n * validation function if `null` or `undefined` should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  greaterThan: {\n    comparand: number;\n    actual: number;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  amount: validate(greaterThan(10)),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function greaterThan(comparand: number) {\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\n  if (comparand === null || comparand === undefined) {\n    throw new Error(`The greaterThan Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\n  }\n\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\n    value = unbox(value) as number | null | undefined as T;\n\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    if (value > comparand) {\n      return {};\n    }\n\n    return {\n      greaterThan: {\n        comparand,\n        actual: value as number,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface GreaterThanOrEqualToValidationError {\n  comparand: number;\n  actual: number;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    greaterThanOrEqualTo?: GreaterThanOrEqualToValidationError;\n  }\n}\n\n/**\n * A validation function that requires the value to be greater than or equal to a number.\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\n * validation function if `null` or `undefined` should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  greaterThanOrEqualTo: {\n    comparand: number;\n    actual: number;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  amount: validate(greaterThanOrEqualTo(10)),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function greaterThanOrEqualTo(comparand: number) {\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\n  if (comparand === null || comparand === undefined) {\n    throw new Error(`The greaterThanOrEqualTo Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\n  }\n\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\n    value = unbox(value) as number | null | undefined as T;\n\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    if (value >= comparand) {\n      return {};\n    }\n\n    return {\n      greaterThanOrEqualTo: {\n        comparand,\n        actual: value as number,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface LessThanValidationError {\n  comparand: number;\n  actual: number;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    lessThan?: LessThanValidationError;\n  }\n}\n\n/**\n * A validation function that requires the value to be less than a number.\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\n * validation function if `null` or `undefined` should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  lessThan: {\n    comparand: number;\n    actual: number;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  amount: validate(lessThan(10)),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function lessThan(comparand: number) {\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\n  if (comparand === null || comparand === undefined) {\n    throw new Error(`The lessThan Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\n  }\n\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\n    value = unbox(value) as number | null | undefined as T;\n\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    if (value < comparand) {\n      return {};\n    }\n\n    return {\n      lessThan: {\n        comparand,\n        actual: value as number,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface LessThanOrEqualToValidationError {\n  comparand: number;\n  actual: number;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    lessThanOrEqualTo?: LessThanOrEqualToValidationError;\n  }\n}\n\n/**\n * A validation function that requires the value to be less than or equal to a number.\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\n * validation function if `null` or `undefined` should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  lessThanOrEqualTo: {\n    comparand: number;\n    actual: number;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  amount: validate(lessThanOrEqualTo(10)),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function lessThanOrEqualTo(comparand: number) {\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\n  if (comparand === null || comparand === undefined) {\n    throw new Error(`The lessThanOrEqualTo Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);\n  }\n\n  return <T extends number | Boxed<number> | null | undefined>(value: T): ValidationErrors => {\n    value = unbox(value) as number | null | undefined as T;\n\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    if (value <= comparand) {\n      return {};\n    }\n\n    return {\n      lessThanOrEqualTo: {\n        comparand,\n        actual: value as number,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface MaxLengthValidationError {\n  maxLength: number;\n  value: string;\n  actualLength: number;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    maxLength?: MaxLengthValidationError;\n  }\n}\n\n/**\n * A validation function that requires a `string` or `array` value to have a maximum length.\n * Considers `null` and `undefined` as valid. Combine this function with the `required`\n * validation function if `null` or `undefined` should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  maxLength: {\n    maxLength: number;\n    value: string;\n    actualLength: number;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  name: validate(maxLength(10)),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function maxLength(maxLengthParam: number) {\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\n  if (maxLengthParam === null || maxLengthParam === undefined) {\n    throw new Error(`The maxLength Validation function requires the maxLength parameter to be a non-null number, got ${maxLengthParam}!`);\n  }\n\n  return <T extends string | Boxed<string> | any[] | Boxed<any[]> | null | undefined>(value: T): ValidationErrors => {\n    value = unbox(value);\n\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    const length = (value as string | any[]).length;\n\n    if (length <= maxLengthParam) {\n      return {};\n    }\n\n    return {\n      maxLength: {\n        maxLength: maxLengthParam,\n        value: value as string,\n        actualLength: length,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface MinLengthValidationError {\n  minLength: number;\n  value: string;\n  actualLength: number;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    minLength?: MinLengthValidationError;\n  }\n}\n\n/**\n * A validation function that requires a `string` or `array` value to have a minimum length.\n * Considers `null`, `undefined`, empty strings and empty arrays as valid. Combine this\n * function with the `required` validation function if these values should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  minLength: {\n    minLength: number;\n    value: string;\n    actualLength: number;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  password: validate(minLength(8)),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function minLength(minLengthParam: number) {\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\n  if (minLengthParam === null || minLengthParam === undefined) {\n    throw new Error(`The minLength Validation function requires the minLength parameter to be a non-null number, got ${minLengthParam}!`);\n  }\n\n  return <T extends string | Boxed<string> | any[] | Boxed<any[]> | null | undefined>(value: T): ValidationErrors => {\n    value = unbox(value);\n\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    const length = (value as string | any[]).length;\n\n    if (length === 0) {\n      return {}; // don't validate empty values to allow optional controls\n    }\n\n    if (length >= minLengthParam) {\n      return {};\n    }\n\n    return {\n      minLength: {\n        minLength: minLengthParam,\n        value: value as string,\n        actualLength: length,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface NotEqualToValidationError<T> {\n  comparand: T;\n  actual: T;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    notEqualTo?: NotEqualToValidationError<any>;\n  }\n}\n\n/**\n * A validation function that requires the value to be strictly not equal (i.e. `!==`)\n * to another value.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  notEqualTo: {\n    comparand: T;\n    actual: T;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  name: validate(notEqualTo('John Doe')),\n})\n```\n */\nexport function notEqualTo<T>(comparand: T) {\n  return <TV extends T | Boxed<T> = T>(value: TV): ValidationErrors => {\n    value = unbox(value) as T as TV;\n\n    if (value !== comparand) {\n      return {};\n    }\n\n    return {\n      notEqualTo: {\n        comparand,\n        actual: value,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface PatternValidationError {\n  pattern: string;\n  actual: string;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    pattern?: PatternValidationError;\n  }\n}\n\n/**\n * A validation function that requires a value to match a regex.\n * Considers `null`, `undefined`, and `''` as valid. Combine this function with the\n * `required` validation function if these values should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  pattern: {\n    pattern: string;\n    actual: string;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  numberWithPeriodsOrCommas: validate(pattern(/^[0-9.,]+$/)),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function pattern(patternParam: RegExp) {\n  // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)\n  if (patternParam === null || patternParam === undefined) {\n    throw new Error(`The pattern Validation function requires the pattern parameter to be a non-null string or regular expression, got ${patternParam}!`);\n  }\n\n  return <T extends string | Boxed<string> | null | undefined>(value: T): ValidationErrors => {\n    value = unbox(value) as string | null | undefined as T;\n\n    if (value === null || value === undefined || (value as string).length === 0) {\n      return {};\n    }\n\n    if (patternParam.test(value as string)) {\n      return {};\n    }\n\n    return {\n      pattern: {\n        pattern: patternParam.toString(),\n        actual: value as string,\n      },\n    };\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\nexport interface RequiredValidationError<T> {\n  actual: T | null | undefined;\n}\n\n// @ts-ignore\ndeclare module 'ngrx-forms/src/state' {\n  export interface ValidationErrors {\n    required?: RequiredValidationError<any>;\n  }\n}\n\n/**\n * A validation function that requires the value to be non-`undefined`, non-'null',\n * and non-empty.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  required: {\n    actual: T | null | undefined;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  name: validate(required),\n})\n```\n */\nexport function required<T>(value: T | Boxed<T> | null | undefined): ValidationErrors {\n  value = unbox(value) as T | null | undefined;\n\n  if (value !== undefined && value !== null && (value as any).length !== 0) {\n    return {};\n  }\n\n  return {\n    required: {\n      actual: value,\n    },\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\n/**\n * A validation function that requires the value to be `false`. Considers `null` and\n * `undefined` as valid. Combine this function with the `required` validation\n * function if `null` or `undefined` should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  required: {\n    actual: boolean;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  disagreeWithTermsOfService: validate(requiredFalse),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function requiredFalse<T extends boolean | Boxed<boolean> | null | undefined>(value: T): ValidationErrors {\n  value = unbox(value) as boolean | null | undefined as T;\n\n  // tslint:disable-next-line:strict-type-predicates\n  if (value === null || value === undefined) {\n    return {};\n  }\n\n  if (!value) {\n    return {};\n  }\n\n  return {\n    required: {\n      actual: value,\n    },\n  };\n}\n","import { Boxed, unbox, ValidationErrors } from 'ngrx-forms';\n\n/**\n * A validation function that requires the value to be `true`. Considers `null` and\n * `undefined` as valid. Combine this function with the `required` validation\n * function if `null` or `undefined` should be considered invalid.\n *\n * The validation error returned by this validation function has the following shape:\n *\n```typescript\n{\n  required: {\n    actual: boolean;\n  };\n}\n```\n *\n * Usually you would use this validation function in conjunction with the `validate`\n * update function to perform synchronous validation in your reducer:\n *\n```typescript\nupdateGroup<MyFormValue>({\n  agreeWithTermsOfService: validate(requiredTrue),\n})\n```\n *\n * Note that this function is generic to allow the compiler to properly infer the type\n * of the `validate` function for both optional and non-optional controls.\n */\nexport function requiredTrue<T extends boolean | Boxed<boolean> | null | undefined>(value: T): ValidationErrors {\n  value = unbox(value) as boolean | null | undefined as T;\n\n  // tslint:disable-next-line:strict-type-predicates\n  if (value === null || value === undefined) {\n    return {};\n  }\n\n  if (value) {\n    return {};\n  }\n\n  return {\n    required: {\n      actual: value,\n    },\n  };\n}\n"],"names":["unbox"],"mappings":"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"}