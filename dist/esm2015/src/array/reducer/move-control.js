import { MoveArrayControlAction } from '../../actions';
import { computeArrayState } from '../../state';
import { childReducer, updateIdRecursive } from './util';
export function move(array, fromIndex, toIndex) {
    const item = array[fromIndex];
    const length = array.length;
    if (fromIndex > toIndex) {
        return [
            ...array.slice(0, toIndex),
            item,
            ...array.slice(toIndex, fromIndex),
            ...array.slice(fromIndex + 1, length),
        ];
    }
    else {
        const targetIndex = toIndex + 1;
        return [
            ...array.slice(0, fromIndex),
            ...array.slice(fromIndex + 1, targetIndex),
            item,
            ...array.slice(targetIndex, length),
        ];
    }
}
export function moveControlReducer(state, action) {
    if (action.type !== MoveArrayControlAction.TYPE) {
        return state;
    }
    if (action.controlId !== state.id) {
        return childReducer(state, action);
    }
    const fromIndex = action.fromIndex;
    const toIndex = action.toIndex;
    if (fromIndex === toIndex) {
        return state;
    }
    if (fromIndex < 0 || toIndex < 0) {
        throw new Error(`fromIndex ${fromIndex} or toIndex ${fromIndex} was negative`);
    }
    if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {
        throw new Error(`fromIndex ${fromIndex} or toIndex ${toIndex} is out of bounds with the length of the controls ${state.controls.length}`);
    }
    let controls = move(state.controls, fromIndex, toIndex);
    controls = controls.map((c, i) => updateIdRecursive(c, `${state.id}.${i}`));
    return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
        wasOrShouldBeDirty: true,
        wasOrShouldBeEnabled: state.isEnabled,
        wasOrShouldBeTouched: state.isTouched,
        wasOrShouldBeSubmitted: state.isSubmitted,
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW92ZS1jb250cm9sLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmdyeC1mb3Jtcy8iLCJzb3VyY2VzIjpbInNyYy9hcnJheS9yZWR1Y2VyL21vdmUtY29udHJvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQVcsc0JBQXNCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFrQixNQUFNLGFBQWEsQ0FBQztBQUNoRSxPQUFPLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRXpELE1BQU0sVUFBVSxJQUFJLENBQUMsS0FBcUIsRUFBRSxTQUFpQixFQUFFLE9BQWU7SUFDNUUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDNUIsSUFBSSxTQUFTLEdBQUcsT0FBTyxFQUFFO1FBQ3ZCLE9BQU87WUFDTCxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQztZQUMxQixJQUFJO1lBQ0osR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUM7WUFDbEMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDO1NBQ3RDLENBQUM7S0FDSDtTQUFNO1FBQ0wsTUFBTSxXQUFXLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztRQUNoQyxPQUFPO1lBQ0wsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUM7WUFDNUIsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsV0FBVyxDQUFDO1lBQzFDLElBQUk7WUFDSixHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQztTQUNwQyxDQUFDO0tBQ0g7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLGtCQUFrQixDQUNoQyxLQUE2QixFQUM3QixNQUF5QjtJQUV6QixJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssc0JBQXNCLENBQUMsSUFBSSxFQUFFO1FBQy9DLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLE1BQU0sQ0FBQyxTQUFTLEtBQUssS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUNqQyxPQUFPLFlBQVksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDcEM7SUFFRCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25DLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7SUFFL0IsSUFBSSxTQUFTLEtBQUssT0FBTyxFQUFFO1FBQ3pCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFFRCxJQUFJLFNBQVMsR0FBRyxDQUFDLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRTtRQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsU0FBUyxlQUFlLFNBQVMsZUFBZSxDQUFDLENBQUM7S0FDaEY7SUFFRCxJQUFJLFNBQVMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxPQUFPLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7UUFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLFNBQVMsZUFBZSxPQUFPLHFEQUFxRCxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7S0FDM0k7SUFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFeEQsUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUU1RSxPQUFPLGlCQUFpQixDQUN0QixLQUFLLENBQUMsRUFBRSxFQUNSLFFBQVEsRUFDUixLQUFLLENBQUMsS0FBSyxFQUNYLEtBQUssQ0FBQyxNQUFNLEVBQ1osS0FBSyxDQUFDLGtCQUFrQixFQUN4QixLQUFLLENBQUMscUJBQXFCLEVBQzNCO1FBQ0Usa0JBQWtCLEVBQUUsSUFBSTtRQUN4QixvQkFBb0IsRUFBRSxLQUFLLENBQUMsU0FBUztRQUNyQyxvQkFBb0IsRUFBRSxLQUFLLENBQUMsU0FBUztRQUNyQyxzQkFBc0IsRUFBRSxLQUFLLENBQUMsV0FBVztLQUMxQyxDQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9ucywgTW92ZUFycmF5Q29udHJvbEFjdGlvbiB9IGZyb20gJy4uLy4uL2FjdGlvbnMnO1xuaW1wb3J0IHsgY29tcHV0ZUFycmF5U3RhdGUsIEZvcm1BcnJheVN0YXRlIH0gZnJvbSAnLi4vLi4vc3RhdGUnO1xuaW1wb3J0IHsgY2hpbGRSZWR1Y2VyLCB1cGRhdGVJZFJlY3Vyc2l2ZSB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlKGFycmF5OiByZWFkb25seSBhbnlbXSwgZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlcikge1xuICBjb25zdCBpdGVtID0gYXJyYXlbZnJvbUluZGV4XTtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBpZiAoZnJvbUluZGV4ID4gdG9JbmRleCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5hcnJheS5zbGljZSgwLCB0b0luZGV4KSxcbiAgICAgIGl0ZW0sXG4gICAgICAuLi5hcnJheS5zbGljZSh0b0luZGV4LCBmcm9tSW5kZXgpLFxuICAgICAgLi4uYXJyYXkuc2xpY2UoZnJvbUluZGV4ICsgMSwgbGVuZ3RoKSxcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdG9JbmRleCArIDE7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLmFycmF5LnNsaWNlKDAsIGZyb21JbmRleCksXG4gICAgICAuLi5hcnJheS5zbGljZShmcm9tSW5kZXggKyAxLCB0YXJnZXRJbmRleCksXG4gICAgICBpdGVtLFxuICAgICAgLi4uYXJyYXkuc2xpY2UodGFyZ2V0SW5kZXgsIGxlbmd0aCksXG4gICAgXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUNvbnRyb2xSZWR1Y2VyPFRWYWx1ZT4oXG4gIHN0YXRlOiBGb3JtQXJyYXlTdGF0ZTxUVmFsdWU+LFxuICBhY3Rpb246IEFjdGlvbnM8VFZhbHVlW10+LFxuKTogRm9ybUFycmF5U3RhdGU8VFZhbHVlPiB7XG4gIGlmIChhY3Rpb24udHlwZSAhPT0gTW92ZUFycmF5Q29udHJvbEFjdGlvbi5UWVBFKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmIChhY3Rpb24uY29udHJvbElkICE9PSBzdGF0ZS5pZCkge1xuICAgIHJldHVybiBjaGlsZFJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gIH1cblxuICBjb25zdCBmcm9tSW5kZXggPSBhY3Rpb24uZnJvbUluZGV4O1xuICBjb25zdCB0b0luZGV4ID0gYWN0aW9uLnRvSW5kZXg7XG5cbiAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlmIChmcm9tSW5kZXggPCAwIHx8IHRvSW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBmcm9tSW5kZXggJHtmcm9tSW5kZXh9IG9yIHRvSW5kZXggJHtmcm9tSW5kZXh9IHdhcyBuZWdhdGl2ZWApO1xuICB9XG5cbiAgaWYgKGZyb21JbmRleCA+PSBzdGF0ZS5jb250cm9scy5sZW5ndGggfHwgdG9JbmRleCA+PSBzdGF0ZS5jb250cm9scy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZyb21JbmRleCAke2Zyb21JbmRleH0gb3IgdG9JbmRleCAke3RvSW5kZXh9IGlzIG91dCBvZiBib3VuZHMgd2l0aCB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9scyAke3N0YXRlLmNvbnRyb2xzLmxlbmd0aH1gKTtcbiAgfVxuXG4gIGxldCBjb250cm9scyA9IG1vdmUoc3RhdGUuY29udHJvbHMsIGZyb21JbmRleCwgdG9JbmRleCk7XG5cbiAgY29udHJvbHMgPSBjb250cm9scy5tYXAoKGMsIGkpID0+IHVwZGF0ZUlkUmVjdXJzaXZlKGMsIGAke3N0YXRlLmlkfS4ke2l9YCkpO1xuXG4gIHJldHVybiBjb21wdXRlQXJyYXlTdGF0ZShcbiAgICBzdGF0ZS5pZCxcbiAgICBjb250cm9scyxcbiAgICBzdGF0ZS52YWx1ZSxcbiAgICBzdGF0ZS5lcnJvcnMsXG4gICAgc3RhdGUucGVuZGluZ1ZhbGlkYXRpb25zLFxuICAgIHN0YXRlLnVzZXJEZWZpbmVkUHJvcGVydGllcyxcbiAgICB7XG4gICAgICB3YXNPclNob3VsZEJlRGlydHk6IHRydWUsXG4gICAgICB3YXNPclNob3VsZEJlRW5hYmxlZDogc3RhdGUuaXNFbmFibGVkLFxuICAgICAgd2FzT3JTaG91bGRCZVRvdWNoZWQ6IHN0YXRlLmlzVG91Y2hlZCxcbiAgICAgIHdhc09yU2hvdWxkQmVTdWJtaXR0ZWQ6IHN0YXRlLmlzU3VibWl0dGVkLFxuICAgIH1cbiAgKTtcbn1cbiJdfQ==