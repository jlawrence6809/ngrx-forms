import * as tslib_1 from "tslib";
import { MoveArrayControlAction } from '../../actions';
import { computeArrayState } from '../../state';
import { childReducer, updateIdRecursive } from './util';
export function move(array, fromIndex, toIndex) {
    var item = array[fromIndex];
    var length = array.length;
    if (fromIndex > toIndex) {
        return tslib_1.__spread(array.slice(0, toIndex), [
            item
        ], array.slice(toIndex, fromIndex), array.slice(fromIndex + 1, length));
    }
    else {
        var targetIndex = toIndex + 1;
        return tslib_1.__spread(array.slice(0, fromIndex), array.slice(fromIndex + 1, targetIndex), [
            item
        ], array.slice(targetIndex, length));
    }
}
export function moveControlReducer(state, action) {
    if (action.type !== MoveArrayControlAction.TYPE) {
        return state;
    }
    if (action.controlId !== state.id) {
        return childReducer(state, action);
    }
    var fromIndex = action.fromIndex;
    var toIndex = action.toIndex;
    if (fromIndex === toIndex) {
        return state;
    }
    if (fromIndex < 0 || toIndex < 0) {
        throw new Error("fromIndex " + fromIndex + " or toIndex " + fromIndex + " was negative");
    }
    if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {
        throw new Error("fromIndex " + fromIndex + " or toIndex " + toIndex + " is out of bounds with the length of the controls " + state.controls.length);
    }
    var controls = move(state.controls, fromIndex, toIndex);
    controls = controls.map(function (c, i) { return updateIdRecursive(c, state.id + "." + i); });
    return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
        wasOrShouldBeDirty: true,
        wasOrShouldBeEnabled: state.isEnabled,
        wasOrShouldBeTouched: state.isTouched,
        wasOrShouldBeSubmitted: state.isSubmitted,
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW92ZS1jb250cm9sLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmdyeC1mb3Jtcy8iLCJzb3VyY2VzIjpbInNyYy9hcnJheS9yZWR1Y2VyL21vdmUtY29udHJvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFXLHNCQUFzQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBa0IsTUFBTSxhQUFhLENBQUM7QUFDaEUsT0FBTyxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUV6RCxNQUFNLFVBQVUsSUFBSSxDQUFDLEtBQXFCLEVBQUUsU0FBaUIsRUFBRSxPQUFlO0lBQzVFLElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5QixJQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQzVCLElBQUksU0FBUyxHQUFHLE9BQU8sRUFBRTtRQUN2Qix3QkFDSyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUM7WUFDMUIsSUFBSTtXQUNELEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxFQUMvQixLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQ3JDO0tBQ0g7U0FBTTtRQUNMLElBQU0sV0FBVyxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEMsd0JBQ0ssS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEVBQ3pCLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxXQUFXLENBQUM7WUFDMUMsSUFBSTtXQUNELEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxFQUNuQztLQUNIO0FBQ0gsQ0FBQztBQUVELE1BQU0sVUFBVSxrQkFBa0IsQ0FDaEMsS0FBNkIsRUFDN0IsTUFBeUI7SUFFekIsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLHNCQUFzQixDQUFDLElBQUksRUFBRTtRQUMvQyxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSSxNQUFNLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDakMsT0FBTyxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQ3BDO0lBRUQsSUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuQyxJQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO0lBRS9CLElBQUksU0FBUyxLQUFLLE9BQU8sRUFBRTtRQUN6QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsSUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJLE9BQU8sR0FBRyxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFhLFNBQVMsb0JBQWUsU0FBUyxrQkFBZSxDQUFDLENBQUM7S0FDaEY7SUFFRCxJQUFJLFNBQVMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxPQUFPLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7UUFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFhLFNBQVMsb0JBQWUsT0FBTywwREFBcUQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFRLENBQUMsQ0FBQztLQUMzSTtJQUVELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUV4RCxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDLElBQUssT0FBQSxpQkFBaUIsQ0FBQyxDQUFDLEVBQUssS0FBSyxDQUFDLEVBQUUsU0FBSSxDQUFHLENBQUMsRUFBeEMsQ0FBd0MsQ0FBQyxDQUFDO0lBRTVFLE9BQU8saUJBQWlCLENBQ3RCLEtBQUssQ0FBQyxFQUFFLEVBQ1IsUUFBUSxFQUNSLEtBQUssQ0FBQyxLQUFLLEVBQ1gsS0FBSyxDQUFDLE1BQU0sRUFDWixLQUFLLENBQUMsa0JBQWtCLEVBQ3hCLEtBQUssQ0FBQyxxQkFBcUIsRUFDM0I7UUFDRSxrQkFBa0IsRUFBRSxJQUFJO1FBQ3hCLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxTQUFTO1FBQ3JDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxTQUFTO1FBQ3JDLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxXQUFXO0tBQzFDLENBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3Rpb25zLCBNb3ZlQXJyYXlDb250cm9sQWN0aW9uIH0gZnJvbSAnLi4vLi4vYWN0aW9ucyc7XG5pbXBvcnQgeyBjb21wdXRlQXJyYXlTdGF0ZSwgRm9ybUFycmF5U3RhdGUgfSBmcm9tICcuLi8uLi9zdGF0ZSc7XG5pbXBvcnQgeyBjaGlsZFJlZHVjZXIsIHVwZGF0ZUlkUmVjdXJzaXZlIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmUoYXJyYXk6IHJlYWRvbmx5IGFueVtdLCBmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKSB7XG4gIGNvbnN0IGl0ZW0gPSBhcnJheVtmcm9tSW5kZXhdO1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLmFycmF5LnNsaWNlKDAsIHRvSW5kZXgpLFxuICAgICAgaXRlbSxcbiAgICAgIC4uLmFycmF5LnNsaWNlKHRvSW5kZXgsIGZyb21JbmRleCksXG4gICAgICAuLi5hcnJheS5zbGljZShmcm9tSW5kZXggKyAxLCBsZW5ndGgpLFxuICAgIF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0b0luZGV4ICsgMTtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uYXJyYXkuc2xpY2UoMCwgZnJvbUluZGV4KSxcbiAgICAgIC4uLmFycmF5LnNsaWNlKGZyb21JbmRleCArIDEsIHRhcmdldEluZGV4KSxcbiAgICAgIGl0ZW0sXG4gICAgICAuLi5hcnJheS5zbGljZSh0YXJnZXRJbmRleCwgbGVuZ3RoKSxcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlQ29udHJvbFJlZHVjZXI8VFZhbHVlPihcbiAgc3RhdGU6IEZvcm1BcnJheVN0YXRlPFRWYWx1ZT4sXG4gIGFjdGlvbjogQWN0aW9uczxUVmFsdWVbXT4sXG4pOiBGb3JtQXJyYXlTdGF0ZTxUVmFsdWU+IHtcbiAgaWYgKGFjdGlvbi50eXBlICE9PSBNb3ZlQXJyYXlDb250cm9sQWN0aW9uLlRZUEUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKGFjdGlvbi5jb250cm9sSWQgIT09IHN0YXRlLmlkKSB7XG4gICAgcmV0dXJuIGNoaWxkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgfVxuXG4gIGNvbnN0IGZyb21JbmRleCA9IGFjdGlvbi5mcm9tSW5kZXg7XG4gIGNvbnN0IHRvSW5kZXggPSBhY3Rpb24udG9JbmRleDtcblxuICBpZiAoZnJvbUluZGV4ID09PSB0b0luZGV4KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaWYgKGZyb21JbmRleCA8IDAgfHwgdG9JbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZyb21JbmRleCAke2Zyb21JbmRleH0gb3IgdG9JbmRleCAke2Zyb21JbmRleH0gd2FzIG5lZ2F0aXZlYCk7XG4gIH1cblxuICBpZiAoZnJvbUluZGV4ID49IHN0YXRlLmNvbnRyb2xzLmxlbmd0aCB8fCB0b0luZGV4ID49IHN0YXRlLmNvbnRyb2xzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZnJvbUluZGV4ICR7ZnJvbUluZGV4fSBvciB0b0luZGV4ICR7dG9JbmRleH0gaXMgb3V0IG9mIGJvdW5kcyB3aXRoIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2xzICR7c3RhdGUuY29udHJvbHMubGVuZ3RofWApO1xuICB9XG5cbiAgbGV0IGNvbnRyb2xzID0gbW92ZShzdGF0ZS5jb250cm9scywgZnJvbUluZGV4LCB0b0luZGV4KTtcblxuICBjb250cm9scyA9IGNvbnRyb2xzLm1hcCgoYywgaSkgPT4gdXBkYXRlSWRSZWN1cnNpdmUoYywgYCR7c3RhdGUuaWR9LiR7aX1gKSk7XG5cbiAgcmV0dXJuIGNvbXB1dGVBcnJheVN0YXRlKFxuICAgIHN0YXRlLmlkLFxuICAgIGNvbnRyb2xzLFxuICAgIHN0YXRlLnZhbHVlLFxuICAgIHN0YXRlLmVycm9ycyxcbiAgICBzdGF0ZS5wZW5kaW5nVmFsaWRhdGlvbnMsXG4gICAgc3RhdGUudXNlckRlZmluZWRQcm9wZXJ0aWVzLFxuICAgIHtcbiAgICAgIHdhc09yU2hvdWxkQmVEaXJ0eTogdHJ1ZSxcbiAgICAgIHdhc09yU2hvdWxkQmVFbmFibGVkOiBzdGF0ZS5pc0VuYWJsZWQsXG4gICAgICB3YXNPclNob3VsZEJlVG91Y2hlZDogc3RhdGUuaXNUb3VjaGVkLFxuICAgICAgd2FzT3JTaG91bGRCZVN1Ym1pdHRlZDogc3RhdGUuaXNTdWJtaXR0ZWQsXG4gICAgfVxuICApO1xufVxuIl19