import * as tslib_1 from "tslib";
import { ALL_NGRX_FORMS_ACTION_TYPES } from './actions';
import { formArrayReducer } from './array/reducer';
import { formControlReducer } from './control/reducer';
import { formGroupReducer } from './group/reducer';
import { isArrayState, isFormState, isGroupState } from './state';
export function formStateReducer(state, action) {
    if (!state) {
        throw new Error('The form state must be defined!');
    }
    if (!isFormState(state)) {
        throw new Error("state must be a form state, got " + state);
    }
    if (isGroupState(state)) {
        return formGroupReducer(state, action);
    }
    if (isArrayState(state)) {
        return formArrayReducer(state, action);
    }
    return formControlReducer(state, action);
}
/**
 * This function creates a reducer function that first applies an action to the state
 * and afterwards applies all given update functions one after another to the resulting
 * form state. However, the update functions are only applied if the form state changed
 * as result of applying the action. If you need the update functions to be applied
 * regardless of whether the state changed (e.g. because the update function closes
 * over variables that may change independently of the form state) you can simply apply
 * the update manually (e.g. `updateFunction(formStateReducer(state, action))`).
 *
 * The following (contrived) example uses this function to create a reducer that after
 * each action validates the child control `name` to be required and sets the child
 * control `email`'s value to be `''` if the name is invalid.
 *
```typescript
interface FormValue {
  name: string;
  email: string;
}

const updateFormState = updateGroup<FormValue>(
  {
    name: validate(required),
  },
  {
    email: (email, parentGroup) =>
      parentGroup.controls.name.isInvalid
        ? setValue('', email)
        : email,
  },
);

const reducer = createFormStateReducerWithUpdate<FormValue>(updateFormState);
```
 */
export function createFormStateReducerWithUpdate(updateFnOrUpdateFnArr) {
    var updateFnArr = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        updateFnArr[_i - 1] = arguments[_i];
    }
    updateFnArr = tslib_1.__spread((Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr]), updateFnArr);
    return function (state, action) {
        var newState = formStateReducer(state, action);
        return newState === state ? state : updateFnArr.reduce(function (s, f) { return f(s); }, newState);
    };
}
function reduceNestedFormState(state, key, action) {
    var _a;
    var value = state[key];
    if (!isFormState(value)) {
        return state;
    }
    return tslib_1.__assign({}, state, (_a = {}, _a[key] = formStateReducer(value, action), _a));
}
function reduceNestedFormStates(state, action) {
    return Object.keys(state).reduce(function (s, key) { return reduceNestedFormState(s, key, action); }, state);
}
/**
 * This function returns an object that can be passed to ngrx's `createReducer`
 * function (available starting with ngrx version 8). By doing this all form
 * state properties on the state will be updated whenever necessary (i.e.
 * whenever an ngrx-forms action is dispatched).
 *
 * To manually update a form state (e.g. to validate it) use
 * `wrapReducerWithFormStateUpdate`.
 */
export function onNgrxForms() {
    return {
        reducer: function (state, action) { return reduceNestedFormStates(state, action); },
        types: ALL_NGRX_FORMS_ACTION_TYPES,
    };
}
/**
 * Define a reducer for a ngrx-forms action. This functions works the same as
 * ngrx's `on` except that you provide the ngrx-forms action class instead of
 * your action creator as a parameter.
 */
export function onNgrxFormsAction(actionCons, reducer) {
    return {
        reducer: function (state, action) { return reducer(reduceNestedFormStates(state, action), action); },
        types: [actionCons.TYPE],
    };
}
/**
 * This function wraps a reducer and returns another reducer that first calls
 * the given reducer and then calls the given update function for the form state
 * that is specified by the form state locator function.
 *
 * The update function is passed the form state and the updated containing state
 * as parameters.
 */
export function wrapReducerWithFormStateUpdate(reducer, formStateLocator, updateFn) {
    return function (state, action) {
        var _a;
        var updatedState = reducer(state, action);
        var formState = formStateLocator(updatedState);
        var formStateKey = Object.keys(updatedState).find(function (key) { return updatedState[key] === formState; });
        var updatedFormState = updateFn(formState, updatedState);
        if (updatedFormState === formState) {
            return updatedState;
        }
        return tslib_1.__assign({}, updatedState, (_a = {}, _a[formStateKey] = updatedFormState, _a));
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25ncngtZm9ybXMvIiwic291cmNlcyI6WyJzcmMvcmVkdWNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsT0FBTyxFQUFXLDJCQUEyQixFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBcUQsWUFBWSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFHckgsTUFBTSxVQUFVLGdCQUFnQixDQUM5QixLQUFtRSxFQUNuRSxNQUFjO0lBRWQsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztLQUNwRDtJQUVELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBbUMsS0FBTyxDQUFDLENBQUM7S0FDN0Q7SUFFRCxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN2QixPQUFPLGdCQUFnQixDQUFDLEtBQUssRUFBRSxNQUFNLENBQVEsQ0FBQztLQUMvQztJQUVELElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sZ0JBQWdCLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBUSxDQUFDO0tBQy9DO0lBRUQsT0FBTyxrQkFBa0IsQ0FBQyxLQUE4QixFQUFFLE1BQU0sQ0FBUSxDQUFDO0FBQzNFLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUNHO0FBQ0gsTUFBTSxVQUFVLGdDQUFnQyxDQUM5QyxxQkFBb0Y7SUFDcEYscUJBQThDO1NB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QUNyQjtRQUVELDRCQUNLLFlBQVksZUFDZCxZQUFZLElBQUcsZ0JBQWdCLE9BQ2hDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjdGlvbiwgQWN0aW9uUmVkdWNlciB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcblxuaW1wb3J0IHsgQWN0aW9ucywgQUxMX05HUlhfRk9STVNfQUNUSU9OX1RZUEVTIH0gZnJvbSAnLi9hY3Rpb25zJztcbmltcG9ydCB7IGZvcm1BcnJheVJlZHVjZXIgfSBmcm9tICcuL2FycmF5L3JlZHVjZXInO1xuaW1wb3J0IHsgZm9ybUNvbnRyb2xSZWR1Y2VyIH0gZnJvbSAnLi9jb250cm9sL3JlZHVjZXInO1xuaW1wb3J0IHsgZm9ybUdyb3VwUmVkdWNlciB9IGZyb20gJy4vZ3JvdXAvcmVkdWNlcic7XG5pbXBvcnQgeyBBYnN0cmFjdENvbnRyb2xTdGF0ZSwgRm9ybUNvbnRyb2xTdGF0ZSwgRm9ybVN0YXRlLCBpc0FycmF5U3RhdGUsIGlzRm9ybVN0YXRlLCBpc0dyb3VwU3RhdGUgfSBmcm9tICcuL3N0YXRlJztcbmltcG9ydCB7IFByb2plY3RGbiB9IGZyb20gJy4vdXBkYXRlLWZ1bmN0aW9uL3V0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybVN0YXRlUmVkdWNlcjxUVmFsdWU+KFxuICBzdGF0ZTogRm9ybVN0YXRlPFRWYWx1ZT4gfCBBYnN0cmFjdENvbnRyb2xTdGF0ZTxUVmFsdWU+IHwgdW5kZWZpbmVkLFxuICBhY3Rpb246IEFjdGlvbixcbik6IEZvcm1TdGF0ZTxUVmFsdWU+IHtcbiAgaWYgKCFzdGF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZvcm0gc3RhdGUgbXVzdCBiZSBkZWZpbmVkIScpO1xuICB9XG5cbiAgaWYgKCFpc0Zvcm1TdGF0ZShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXRlIG11c3QgYmUgYSBmb3JtIHN0YXRlLCBnb3QgJHtzdGF0ZX1gKTtcbiAgfVxuXG4gIGlmIChpc0dyb3VwU3RhdGUoc3RhdGUpKSB7XG4gICAgcmV0dXJuIGZvcm1Hcm91cFJlZHVjZXIoc3RhdGUsIGFjdGlvbikgYXMgYW55O1xuICB9XG5cbiAgaWYgKGlzQXJyYXlTdGF0ZShzdGF0ZSkpIHtcbiAgICByZXR1cm4gZm9ybUFycmF5UmVkdWNlcihzdGF0ZSwgYWN0aW9uKSBhcyBhbnk7XG4gIH1cblxuICByZXR1cm4gZm9ybUNvbnRyb2xSZWR1Y2VyKHN0YXRlIGFzIEZvcm1Db250cm9sU3RhdGU8YW55PiwgYWN0aW9uKSBhcyBhbnk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGZpcnN0IGFwcGxpZXMgYW4gYWN0aW9uIHRvIHRoZSBzdGF0ZVxuICogYW5kIGFmdGVyd2FyZHMgYXBwbGllcyBhbGwgZ2l2ZW4gdXBkYXRlIGZ1bmN0aW9ucyBvbmUgYWZ0ZXIgYW5vdGhlciB0byB0aGUgcmVzdWx0aW5nXG4gKiBmb3JtIHN0YXRlLiBIb3dldmVyLCB0aGUgdXBkYXRlIGZ1bmN0aW9ucyBhcmUgb25seSBhcHBsaWVkIGlmIHRoZSBmb3JtIHN0YXRlIGNoYW5nZWRcbiAqIGFzIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgYWN0aW9uLiBJZiB5b3UgbmVlZCB0aGUgdXBkYXRlIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHN0YXRlIGNoYW5nZWQgKGUuZy4gYmVjYXVzZSB0aGUgdXBkYXRlIGZ1bmN0aW9uIGNsb3Nlc1xuICogb3ZlciB2YXJpYWJsZXMgdGhhdCBtYXkgY2hhbmdlIGluZGVwZW5kZW50bHkgb2YgdGhlIGZvcm0gc3RhdGUpIHlvdSBjYW4gc2ltcGx5IGFwcGx5XG4gKiB0aGUgdXBkYXRlIG1hbnVhbGx5IChlLmcuIGB1cGRhdGVGdW5jdGlvbihmb3JtU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pKWApLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgKGNvbnRyaXZlZCkgZXhhbXBsZSB1c2VzIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcmVkdWNlciB0aGF0IGFmdGVyXG4gKiBlYWNoIGFjdGlvbiB2YWxpZGF0ZXMgdGhlIGNoaWxkIGNvbnRyb2wgYG5hbWVgIHRvIGJlIHJlcXVpcmVkIGFuZCBzZXRzIHRoZSBjaGlsZFxuICogY29udHJvbCBgZW1haWxgJ3MgdmFsdWUgdG8gYmUgYCcnYCBpZiB0aGUgbmFtZSBpcyBpbnZhbGlkLlxuICpcbmBgYHR5cGVzY3JpcHRcbmludGVyZmFjZSBGb3JtVmFsdWUge1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmNvbnN0IHVwZGF0ZUZvcm1TdGF0ZSA9IHVwZGF0ZUdyb3VwPEZvcm1WYWx1ZT4oXG4gIHtcbiAgICBuYW1lOiB2YWxpZGF0ZShyZXF1aXJlZCksXG4gIH0sXG4gIHtcbiAgICBlbWFpbDogKGVtYWlsLCBwYXJlbnRHcm91cCkgPT5cbiAgICAgIHBhcmVudEdyb3VwLmNvbnRyb2xzLm5hbWUuaXNJbnZhbGlkXG4gICAgICAgID8gc2V0VmFsdWUoJycsIGVtYWlsKVxuICAgICAgICA6IGVtYWlsLFxuICB9LFxuKTtcblxuY29uc3QgcmVkdWNlciA9IGNyZWF0ZUZvcm1TdGF0ZVJlZHVjZXJXaXRoVXBkYXRlPEZvcm1WYWx1ZT4odXBkYXRlRm9ybVN0YXRlKTtcbmBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9ybVN0YXRlUmVkdWNlcldpdGhVcGRhdGU8VFZhbHVlPihcbiAgdXBkYXRlRm5PclVwZGF0ZUZuQXJyOiBQcm9qZWN0Rm48Rm9ybVN0YXRlPFRWYWx1ZT4+IHwgUHJvamVjdEZuPEZvcm1TdGF0ZTxUVmFsdWU+PltdLFxuICAuLi51cGRhdGVGbkFycjogUHJvamVjdEZuPEZvcm1TdGF0ZTxUVmFsdWU+PltdXG4pOiBBY3Rpb25SZWR1Y2VyPEZvcm1TdGF0ZTxUVmFsdWU+PiB7XG4gIHVwZGF0ZUZuQXJyID0gWy4uLihBcnJheS5pc0FycmF5KHVwZGF0ZUZuT3JVcGRhdGVGbkFycikgPyB1cGRhdGVGbk9yVXBkYXRlRm5BcnIgOiBbdXBkYXRlRm5PclVwZGF0ZUZuQXJyXSksIC4uLnVwZGF0ZUZuQXJyXTtcbiAgcmV0dXJuIChzdGF0ZTogRm9ybVN0YXRlPFRWYWx1ZT4gfCB1bmRlZmluZWQsIGFjdGlvbjogQWN0aW9uKTogRm9ybVN0YXRlPFRWYWx1ZT4gPT4ge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gZm9ybVN0YXRlUmVkdWNlcihzdGF0ZSBhcyBBYnN0cmFjdENvbnRyb2xTdGF0ZTxUVmFsdWU+LCBhY3Rpb24pO1xuICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gc3RhdGUgPyBzdGF0ZSA6IHVwZGF0ZUZuQXJyLnJlZHVjZSgocywgZikgPT4gZihzKSwgbmV3U3RhdGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWR1Y2VOZXN0ZWRGb3JtU3RhdGU8VFN0YXRlPihzdGF0ZTogVFN0YXRlLCBrZXk6IGtleW9mIFRTdGF0ZSwgYWN0aW9uOiBBY3Rpb24pOiBUU3RhdGUge1xuICBjb25zdCB2YWx1ZSA9IHN0YXRlW2tleV07XG5cbiAgaWYgKCFpc0Zvcm1TdGF0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIFtrZXldOiBmb3JtU3RhdGVSZWR1Y2VyKHZhbHVlLCBhY3Rpb24pLFxuICB9O1xufVxuXG5mdW5jdGlvbiByZWR1Y2VOZXN0ZWRGb3JtU3RhdGVzPFRTdGF0ZT4oc3RhdGU6IFRTdGF0ZSwgYWN0aW9uOiBBY3Rpb24pOiBUU3RhdGUge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc3RhdGUpLnJlZHVjZSgocywga2V5KSA9PiByZWR1Y2VOZXN0ZWRGb3JtU3RhdGUocywga2V5IGFzIGtleW9mIFRTdGF0ZSwgYWN0aW9uKSwgc3RhdGUpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIG5ncngncyBgY3JlYXRlUmVkdWNlcmBcbiAqIGZ1bmN0aW9uIChhdmFpbGFibGUgc3RhcnRpbmcgd2l0aCBuZ3J4IHZlcnNpb24gOCkuIEJ5IGRvaW5nIHRoaXMgYWxsIGZvcm1cbiAqIHN0YXRlIHByb3BlcnRpZXMgb24gdGhlIHN0YXRlIHdpbGwgYmUgdXBkYXRlZCB3aGVuZXZlciBuZWNlc3NhcnkgKGkuZS5cbiAqIHdoZW5ldmVyIGFuIG5ncngtZm9ybXMgYWN0aW9uIGlzIGRpc3BhdGNoZWQpLlxuICpcbiAqIFRvIG1hbnVhbGx5IHVwZGF0ZSBhIGZvcm0gc3RhdGUgKGUuZy4gdG8gdmFsaWRhdGUgaXQpIHVzZVxuICogYHdyYXBSZWR1Y2VyV2l0aEZvcm1TdGF0ZVVwZGF0ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk5ncnhGb3JtczxUU3RhdGUgPSBhbnk+KCk6IHsgcmVkdWNlcjogQWN0aW9uUmVkdWNlcjxUU3RhdGU+OyB0eXBlczogc3RyaW5nW10gfSB7XG4gIHJldHVybiB7XG4gICAgcmVkdWNlcjogKHN0YXRlLCBhY3Rpb24pID0+IHJlZHVjZU5lc3RlZEZvcm1TdGF0ZXMoc3RhdGUhLCBhY3Rpb24pLFxuICAgIHR5cGVzOiBBTExfTkdSWF9GT1JNU19BQ1RJT05fVFlQRVMsXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ29uc3RydWN0b3Ige1xuICBuZXcoLi4uYXJnczogYW55W10pOiBBY3Rpb25zPGFueT47XG4gIHJlYWRvbmx5IFRZUEU6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgQ3JlYXRlZEFjdGlvbjxUQWN0aW9uQ29ucz4gPSBUQWN0aW9uQ29ucyBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGluZmVyIFRBY3Rpb24gPyBUQWN0aW9uIDogbmV2ZXI7XG5cbi8qKlxuICogRGVmaW5lIGEgcmVkdWNlciBmb3IgYSBuZ3J4LWZvcm1zIGFjdGlvbi4gVGhpcyBmdW5jdGlvbnMgd29ya3MgdGhlIHNhbWUgYXNcbiAqIG5ncngncyBgb25gIGV4Y2VwdCB0aGF0IHlvdSBwcm92aWRlIHRoZSBuZ3J4LWZvcm1zIGFjdGlvbiBjbGFzcyBpbnN0ZWFkIG9mXG4gKiB5b3VyIGFjdGlvbiBjcmVhdG9yIGFzIGEgcGFyYW1ldGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25OZ3J4Rm9ybXNBY3Rpb248XG4gIFRBY3Rpb25Db25zIGV4dGVuZHMgQWN0aW9uQ29uc3RydWN0b3IsXG4gIFRTdGF0ZVxuPihcbiAgYWN0aW9uQ29uczogVEFjdGlvbkNvbnMsXG4gIHJlZHVjZXI6IChzdGF0ZTogVFN0YXRlLCBhY3Rpb246IENyZWF0ZWRBY3Rpb248VEFjdGlvbkNvbnM+KSA9PiBUU3RhdGUsXG4pOiB7IHJlZHVjZXI6IEFjdGlvblJlZHVjZXI8VFN0YXRlPjsgdHlwZXM6IHN0cmluZ1tdIH0ge1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXI6IChzdGF0ZSwgYWN0aW9uKSA9PiByZWR1Y2VyKHJlZHVjZU5lc3RlZEZvcm1TdGF0ZXMoc3RhdGUhLCBhY3Rpb24pLCBhY3Rpb24gYXMgYW55KSxcbiAgICB0eXBlczogW2FjdGlvbkNvbnMuVFlQRV0sXG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3cmFwcyBhIHJlZHVjZXIgYW5kIHJldHVybnMgYW5vdGhlciByZWR1Y2VyIHRoYXQgZmlyc3QgY2FsbHNcbiAqIHRoZSBnaXZlbiByZWR1Y2VyIGFuZCB0aGVuIGNhbGxzIHRoZSBnaXZlbiB1cGRhdGUgZnVuY3Rpb24gZm9yIHRoZSBmb3JtIHN0YXRlXG4gKiB0aGF0IGlzIHNwZWNpZmllZCBieSB0aGUgZm9ybSBzdGF0ZSBsb2NhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSB1cGRhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBmb3JtIHN0YXRlIGFuZCB0aGUgdXBkYXRlZCBjb250YWluaW5nIHN0YXRlXG4gKiBhcyBwYXJhbWV0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFJlZHVjZXJXaXRoRm9ybVN0YXRlVXBkYXRlPFRTdGF0ZSwgVEZvcm1TdGF0ZSBleHRlbmRzIEFic3RyYWN0Q29udHJvbFN0YXRlPGFueT4+KFxuICByZWR1Y2VyOiBBY3Rpb25SZWR1Y2VyPFRTdGF0ZT4sXG4gIGZvcm1TdGF0ZUxvY2F0b3I6IChzdGF0ZTogVFN0YXRlKSA9PiBURm9ybVN0YXRlLFxuICB1cGRhdGVGbjogKGZvcm1TdGF0ZTogVEZvcm1TdGF0ZSwgc3RhdGU6IFRTdGF0ZSkgPT4gVEZvcm1TdGF0ZSxcbik6IEFjdGlvblJlZHVjZXI8VFN0YXRlPiB7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZSA9IHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG5cbiAgICBjb25zdCBmb3JtU3RhdGUgPSBmb3JtU3RhdGVMb2NhdG9yKHVwZGF0ZWRTdGF0ZSk7XG4gICAgY29uc3QgZm9ybVN0YXRlS2V5ID0gT2JqZWN0LmtleXModXBkYXRlZFN0YXRlKS5maW5kKGtleSA9PiB1cGRhdGVkU3RhdGVba2V5IGFzIGtleW9mIFRTdGF0ZV0gYXMgYW55ID09PSBmb3JtU3RhdGUpITtcblxuICAgIGNvbnN0IHVwZGF0ZWRGb3JtU3RhdGUgPSB1cGRhdGVGbihmb3JtU3RhdGUsIHVwZGF0ZWRTdGF0ZSk7XG5cbiAgICBpZiAodXBkYXRlZEZvcm1TdGF0ZSA9PT0gZm9ybVN0YXRlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlZFN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi51cGRhdGVkU3RhdGUsXG4gICAgICBbZm9ybVN0YXRlS2V5XTogdXBkYXRlZEZvcm1TdGF0ZSxcbiAgICB9O1xuICB9O1xufVxuIl19